package com.lake.processor;

import com.lake.easyinject.Singleton;
import com.lake.easyinject.SingletonType;
import java.io.BufferedWriter;
import java.io.IOException;
import java.util.Set;
import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Messager;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;

@SupportedAnnotationTypes("com.lake.easyinject.Singleton")
public class SingletonAnnotationProcessor extends AbstractProcessor {
    private static final String IMPL_SUFFIX = "_Single";

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {
        Messager messager = processingEnv.getMessager();
        if (annotations.isEmpty()) {
            return false;
        }
        collectSingletonFiles(annotations, env, messager);
        return true;
    }

    private void collectSingletonFiles(Set<? extends TypeElement> annotations, RoundEnvironment env, Messager messager) {
        for (TypeElement annotation : annotations) {
            Set<? extends Element> elements = env.getElementsAnnotatedWith(annotation);
            for (Element element : elements) {
                if (element.getKind() == ElementKind.CLASS) {
                    TypeElement classElement = (TypeElement) element;
                    if (checkIsAbstractAble(classElement)) {
                        createSingletonFile(classElement.getQualifiedName().toString(), element.getAnnotation(Singleton.class).value());
                    } else {
                        messager.printMessage(Diagnostic.Kind.ERROR, "@Singleton is only valid for Inheritable class", element);
                    }
                } else {
                    messager.printMessage(Diagnostic.Kind.ERROR, "@Singleton is only valid for Inheritable class", element);
                }
            }
        }
    }

    /**
     * check class is or not abstract
     *
     * @return
     */
    private boolean checkIsAbstractAble(TypeElement classElement) {
        return !classElement.getModifiers().contains(Modifier.FINAL);
    }

    private void createSingletonFile(String name, SingletonType type) {
        BufferedWriter writer = null;
        try {
            JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(name + IMPL_SUFFIX);
            int period = name.lastIndexOf('.');
            String myPackage = period > 0 ? name.substring(0, period) : null;
            String superName = name.substring(period > 0 ? period + 1 : 0);
            String className = superName + IMPL_SUFFIX;
            writer = new BufferedWriter(sourceFile.openWriter());
            if (myPackage != null) {
                writer.write("package " + myPackage + ";\n\n");
            }
            writeAnnotationInfo(writer);
            writeSingleton(writer, className, superName, type);
            writer.flush();
        } catch (IOException e) {
            throw new RuntimeException("Could not write source for " + name, e);
        } finally {
            if (writer != null) {
                try {
                    writer.close();
                } catch (IOException e) {
                    //Silent
                }
            }
        }
    }

    private void writeSingleton(BufferedWriter writer, String className,
                                String superName, SingletonType type) throws IOException {
        switch (type) {
            case DLC:
                writeSingletonDLCType(writer, className, superName);
                break;
            case INNER_STATIC:
                writeSingletonInnerStaticType(writer, className, superName);
                break;
            case STATIC_BOX:
                writeSingletonStaticBoxType(writer, className, superName);
                break;
        }
    }

    private void writeAnnotationInfo(BufferedWriter writer) throws IOException {
        writer.write("/**\n");
        writer.write(" * This class is generated by easyinject.\n");
        writer.write(" * please do not edit it.\n");
        writer.write(" * @author lake\n");
        writer.write(" */\n");
    }

    /**
     * singleton with double check lock mode
     *
     * @param writer
     * @param className name of the new singleton class which auto created
     * @param superName name of the abstract class
     */
    private void writeSingletonDLCType(BufferedWriter writer, String className, String superName) throws IOException {
        writer.write("public class " + className + " extends " + superName + " {\n");
        writer.write("    private volatile static " + className + " instance;\n\n");
        writer.write("    private " + className + "(){}\n\n");
        writer.write("    public static " + className + " getInstance() {\n");
        writer.write("        if (instance == null) {\n");
        writer.write("            synchronized (" + className + ".class) {\n");
        writer.write("                if (instance == null)\n");
        writer.write("                    instance = new " + className + "();\n");
        writer.write("            }\n");
        writer.write("        }\n");
        writer.write("        return instance;\n");
        writer.write("    }\n\n");
        writer.write("}\n");
    }

    /**
     * singleton with inner static method
     *
     * @param writer
     * @param className name of the new singleton class which auto created
     * @param superName name of the abstract class
     * @throws IOException
     */
    private void writeSingletonInnerStaticType(BufferedWriter writer, String className, String superName) throws IOException {
        writer.write("public class " + className + " extends " + superName + " {\n");
        writer.write("    private static class " + className + "Handler {\n");
        writer.write("        private static " + className + " instance = new " + className + "();\n");
        writer.write("    }\n\n");
        writer.write("    private " + className + "(){}\n\n");
        writer.write("    public static " + className + " getInstance() {\n");
        writer.write("        return " + className + "Handler.instance;\n");
        writer.write("    }\n\n");
        writer.write("}\n");
    }

    /**
     * singleton with static newInstance box
     *
     * @param writer
     * @param className name of the new singleton class which auto created
     * @param superName name of the abstract class
     * @throws IOException
     */
    private void writeSingletonStaticBoxType(BufferedWriter writer, String className, String superName) throws IOException {
        writer.write("public class " + className + " extends " + superName + " {\n");
        writer.write("    private static " + className + " instance;\n\n");
        writer.write("    private " + className + "(){}\n\n");
        writer.write("    static {\n");
        writer.write("        instance = new " + className + "();\n");
        writer.write("    }\n\n");
        writer.write("    public static " + className + " getInstance() {\n");
        writer.write("        return instance;\n");
        writer.write("    }\n\n");
        writer.write("}\n");
    }
}